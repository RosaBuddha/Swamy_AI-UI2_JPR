import React, { useState, useEffect } from 'react';
import { Button } from '../ui/button';
import { Textarea } from '../ui/textarea';
import { Input } from '../ui/Input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card';
import { useToast } from '@/hooks/use-toast';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { ArrowLeft, Plus, Trash2, Edit, Search, ChevronLeft, ChevronRight, X, Copy, CheckCircle } from 'lucide-react';
import { Switch } from '../ui/switch';
import { Modal } from '../ui/Modal';
import { RichTextEditor } from '../ui/RichTextEditor';
import type { MockResponse } from '@shared/schema';
import { FollowUpChipForm } from './FollowUpChipForm';

interface AdminPageProps {
  onBack: () => void;
}

export const AdminPage: React.FC<AdminPageProps> = ({ onBack }) => {
  const [activeTab, setActiveTab] = useState<'home' | 'responses' | 'system'>('home');
  const [openingText, setOpeningText] = useState('');
  const [supportingText, setSupportingText] = useState('');
  const [introQuestions, setIntroQuestions] = useState('');
  const [isAddingMockResponse, setIsAddingMockResponse] = useState(false);
  const [editingMockResponse, setEditingMockResponse] = useState<MockResponse | null>(null);
  const [newMockQuestion, setNewMockQuestion] = useState('');
  const [newMockResponse, setNewMockResponse] = useState('');
  const [showTryAsking, setShowTryAsking] = useState(false);
  const [tryAskingPrompts, setTryAskingPrompts] = useState<string[]>([]);
  const [newTryAskingPrompt, setNewTryAskingPrompt] = useState('');
  const [showFollowUp, setShowFollowUp] = useState(false);
  const [followUpQuestion, setFollowUpQuestion] = useState('');
  const [followUpChips, setFollowUpChips] = useState<string[]>([]);
  const [followUpResponses, setFollowUpResponses] = useState<string[]>([]);
  const [followUpResponseTypes, setFollowUpResponseTypes] = useState<string[]>([]);
  const [followUpLinkedResponseIds, setFollowUpLinkedResponseIds] = useState<number[]>([]);
  const [newFollowUpChip, setNewFollowUpChip] = useState('');
  const [newFollowUpResponse, setNewFollowUpResponse] = useState('');
  const [newFollowUpResponseType, setNewFollowUpResponseType] = useState<'custom' | 'existing'>('custom');
  const [newFollowUpLinkedResponseId, setNewFollowUpLinkedResponseId] = useState<number | null>(null);
  const [useRichTextForIntro, setUseRichTextForIntro] = useState(false);
  const [useRichTextForSupporting, setUseRichTextForSupporting] = useState(false);
  const [useRichTextForQuestions, setUseRichTextForQuestions] = useState(false);
  const [tryAskingEnabled, setTryAskingEnabled] = useState(true);
  const [systemPrompt, setSystemPrompt] = useState('');

  // Mock responses pagination and search
  const [searchTerm, setSearchTerm] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 10;

  // Copy state tracking
  const [copiedQuestions, setCopiedQuestions] = useState<Set<number>>(new Set());

  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch current opening text
  const { data: openingTextSetting, isLoading: isLoadingOpening } = useQuery({
    queryKey: ['/api/settings', 'opening_text'],
    queryFn: () => fetch('/api/settings/opening_text').then(res => res.json())
  });

  // Fetch current supporting text
  const { data: supportingTextSetting, isLoading: isLoadingSupporting } = useQuery({
    queryKey: ['/api/settings', 'supporting_text'],
    queryFn: () => fetch('/api/settings/supporting_text').then(res => res.json())
  });

  // Fetch current intro questions
  const { data: introQuestionsSetting, isLoading: isLoadingQuestions } = useQuery({
    queryKey: ['/api/settings', 'intro_questions'],
    queryFn: () => fetch('/api/settings/intro_questions').then(res => res.json())
  });

  // Fetch try asking enabled setting
  const { data: tryAskingEnabledSetting, isLoading: isLoadingTryAskingEnabled } = useQuery({
    queryKey: ['/api/settings', 'try_asking_enabled'],
    queryFn: () => fetch('/api/settings/try_asking_enabled').then(res => res.json())
  });

  // Fetch system prompt setting
  const { data: systemPromptSetting, isLoading: isLoadingSystemPrompt } = useQuery({
    queryKey: ['/api/settings', 'system_prompt'],
    queryFn: () => fetch('/api/settings/system_prompt').then(res => res.json())
  });

  // Fetch mock responses
  const { data: mockResponses, isLoading: isLoadingMockResponses } = useQuery({
    queryKey: ['/api/mock-responses'],
    queryFn: () => fetch('/api/mock-responses').then(res => res.json())
  });

  // Update opening text mutation
  const updateOpeningTextMutation = useMutation({
    mutationFn: (value: string) => 
      apiRequest('/api/settings/opening_text', {
        method: 'PUT',
        body: JSON.stringify({ value }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/settings', 'opening_text'] });
      toast({
        title: "Success",
        description: "Opening text updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update opening text",
        variant: "destructive",
      });
    },
  });

  // Update supporting text mutation
  const updateSupportingTextMutation = useMutation({
    mutationFn: (value: string) => 
      apiRequest('/api/settings/supporting_text', {
        method: 'PUT',
        body: JSON.stringify({ value }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/settings', 'supporting_text'] });
      toast({
        title: "Success",
        description: "Supporting text updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update supporting text",
        variant: "destructive",
      });
    },
  });

  // Update intro questions mutation
  const updateIntroQuestionsMutation = useMutation({
    mutationFn: (value: string) => 
      apiRequest('/api/settings/intro_questions', {
        method: 'PUT',
        body: JSON.stringify({ value }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/settings', 'intro_questions'] });
      toast({
        title: "Success",
        description: "Intro questions updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update intro questions",
        variant: "destructive",
      });
    },
  });

  // Update try asking enabled mutation
  const updateTryAskingEnabledMutation = useMutation({
    mutationFn: (value: boolean) => 
      apiRequest('/api/settings/try_asking_enabled', {
        method: 'PUT',
        body: JSON.stringify({ value: value.toString() }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/settings', 'try_asking_enabled'] });
      toast({
        title: "Success",
        description: "Try asking suggestions setting updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update try asking suggestions setting",
        variant: "destructive",
      });
    },
  });

  // Update system prompt mutation
  const updateSystemPromptMutation = useMutation({
    mutationFn: (value: string) => 
      apiRequest('/api/settings/system_prompt', {
        method: 'PUT',
        body: JSON.stringify({ value }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/settings', 'system_prompt'] });
      toast({
        title: "Success",
        description: "System prompt updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update system prompt",
        variant: "destructive",
      });
    },
  });

  // Create mock response mutation
  const createMockResponseMutation = useMutation({
    mutationFn: (data: { question: string; response: string; showTryAsking?: boolean; tryAskingPrompts?: string[]; showFollowUp?: boolean; followUpQuestion?: string; followUpChips?: string[]; followUpResponses?: string[]; followUpResponseTypes?: string[]; followUpLinkedResponseIds?: number[] }) => 
      apiRequest('/api/mock-responses', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/mock-responses'] });
      setIsAddingMockResponse(false);
      setNewMockQuestion('');
      setNewMockResponse('');
      setShowTryAsking(false);
      setTryAskingPrompts([]);
      setShowFollowUp(false);
      setFollowUpQuestion('');
      setFollowUpChips([]);
      setFollowUpResponses([]);
      setFollowUpResponseTypes([]);
      setFollowUpLinkedResponseIds([]);
      setNewFollowUpChip('');
      setNewFollowUpResponse('');
      setNewFollowUpResponseType('custom');
      setNewFollowUpLinkedResponseId(null);
      toast({
        title: "Success",
        description: "Mock response created successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to create mock response",
        variant: "destructive",
      });
    },
  });

  // Update mock response mutation
  const updateMockResponseMutation = useMutation({
    mutationFn: (data: { id: number; question: string; response: string; showTryAsking?: boolean; tryAskingPrompts?: string[]; showFollowUp?: boolean; followUpQuestion?: string; followUpChips?: string[]; followUpResponses?: string[]; followUpResponseTypes?: string[]; followUpLinkedResponseIds?: number[] }) => 
      apiRequest(`/api/mock-responses/${data.id}`, {
        method: 'PUT',
        body: JSON.stringify({ 
          question: data.question, 
          response: data.response, 
          showTryAsking: data.showTryAsking,
          tryAskingPrompts: data.tryAskingPrompts,
          showFollowUp: data.showFollowUp,
          followUpQuestion: data.followUpQuestion,
          followUpChips: data.followUpChips,
          followUpResponses: data.followUpResponses,
          followUpResponseTypes: data.followUpResponseTypes,
          followUpLinkedResponseIds: data.followUpLinkedResponseIds
        }),
        headers: {
          'Content-Type': 'application/json',
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/mock-responses'] });
      setEditingMockResponse(null);
      setNewMockQuestion('');
      setNewMockResponse('');
      setShowTryAsking(false);
      setTryAskingPrompts([]);
      setShowFollowUp(false);
      setFollowUpQuestion('');
      setFollowUpChips([]);
      setFollowUpResponses([]);
      setFollowUpResponseTypes([]);
      setFollowUpLinkedResponseIds([]);
      setNewFollowUpChip('');
      setNewFollowUpResponse('');
      setNewFollowUpResponseType('custom');
      setNewFollowUpLinkedResponseId(null);
      toast({
        title: "Success",
        description: "Mock response updated successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to update mock response",
        variant: "destructive",
      });
    },
  });

  // Delete mock response mutation
  const deleteMockResponseMutation = useMutation({
    mutationFn: (id: number) => 
      apiRequest(`/api/mock-responses/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/mock-responses'] });
      toast({
        title: "Success",
        description: "Mock response deleted successfully",
      });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to delete mock response",
        variant: "destructive",
      });
    },
  });

  useEffect(() => {
    if (openingTextSetting?.value) {
      setOpeningText(openingTextSetting.value);
    }
  }, [openingTextSetting]);

  useEffect(() => {
    if (supportingTextSetting?.value) {
      setSupportingText(supportingTextSetting.value);
    }
  }, [supportingTextSetting]);

  useEffect(() => {
    if (introQuestionsSetting?.value) {
      setIntroQuestions(introQuestionsSetting.value);
    }
  }, [introQuestionsSetting]);

  useEffect(() => {
    if (tryAskingEnabledSetting?.value) {
      setTryAskingEnabled(tryAskingEnabledSetting.value === 'true');
    }
  }, [tryAskingEnabledSetting]);

  useEffect(() => {
    if (systemPromptSetting?.value) {
      setSystemPrompt(systemPromptSetting.value);
    }
  }, [systemPromptSetting]);

  useEffect(() => {
    if (editingMockResponse) {
      setNewMockQuestion(editingMockResponse.question);
      setNewMockResponse(editingMockResponse.response);
    }
  }, [editingMockResponse]);

  const handleSaveOpening = () => {
    updateOpeningTextMutation.mutate(openingText);
  };

  const handleSaveSupporting = () => {
    updateSupportingTextMutation.mutate(supportingText);
  };

  const handleSaveQuestions = () => {
    updateIntroQuestionsMutation.mutate(introQuestions);
  };

  const handleSaveTryAskingEnabled = () => {
    updateTryAskingEnabledMutation.mutate(tryAskingEnabled);
  };

  const handleSaveSystemPrompt = () => {
    updateSystemPromptMutation.mutate(systemPrompt);
  };

  const handleCreateMockResponse = () => {
    const trimmedQuestion = newMockQuestion.trim();
    const trimmedResponse = newMockResponse.trim();

    if (trimmedQuestion && trimmedResponse && trimmedResponse !== '<p></p>') {
      createMockResponseMutation.mutate({
        question: trimmedQuestion,
        response: trimmedResponse,
        showTryAsking,
        tryAskingPrompts: showTryAsking ? tryAskingPrompts : [],
        showFollowUp,
        followUpQuestion: showFollowUp ? followUpQuestion.trim() : '',
        followUpChips: showFollowUp ? followUpChips : [],
        followUpResponses: showFollowUp ? followUpResponses : [],
        followUpResponseTypes: showFollowUp ? followUpResponseTypes : [],
        followUpLinkedResponseIds: showFollowUp ? followUpLinkedResponseIds : [],
      });
    }
  };

  const handleUpdateMockResponse = () => {
    const trimmedQuestion = newMockQuestion.trim();
    const trimmedResponse = newMockResponse.trim();

    if (editingMockResponse && trimmedQuestion && trimmedResponse && trimmedResponse !== '<p></p>') {
      updateMockResponseMutation.mutate({
        id: editingMockResponse.id,
        question: trimmedQuestion,
        response: trimmedResponse,
        showTryAsking,
        tryAskingPrompts: showTryAsking ? tryAskingPrompts : [],
        showFollowUp,
        followUpQuestion: showFollowUp ? followUpQuestion.trim() : '',
        followUpChips: showFollowUp ? followUpChips : [],
        followUpResponses: showFollowUp ? followUpResponses : [],
        followUpResponseTypes: showFollowUp ? followUpResponseTypes : [],
        followUpLinkedResponseIds: showFollowUp ? followUpLinkedResponseIds : [],
      });
    }
  };

  const handleDeleteMockResponse = (id: number) => {
    deleteMockResponseMutation.mutate(id);
  };

  const handleEditMockResponse = (mockResponse: MockResponse) => {
    setEditingMockResponse(mockResponse);
    setNewMockQuestion(mockResponse.question);
    setNewMockResponse(mockResponse.response);
    setShowTryAsking(mockResponse.showTryAsking || false);
    setTryAskingPrompts(mockResponse.tryAskingPrompts || []);
    setShowFollowUp(mockResponse.showFollowUp || false);
    setFollowUpQuestion(mockResponse.followUpQuestion || '');
    setFollowUpChips(mockResponse.followUpChips || []);
    setFollowUpResponses(mockResponse.followUpResponses || []);
    setFollowUpResponseTypes(mockResponse.followUpResponseTypes || []);
    setFollowUpLinkedResponseIds(mockResponse.followUpLinkedResponseIds || []);
  };

  const handleCancelEdit = () => {
    setEditingMockResponse(null);
    setNewMockQuestion('');
    setNewMockResponse('');
    setShowTryAsking(false);
    setTryAskingPrompts([]);
    setShowFollowUp(false);
    setFollowUpQuestion('');
    setFollowUpChips([]);
    setFollowUpResponses([]);
    setFollowUpResponseTypes([]);
    setFollowUpLinkedResponseIds([]);
    setNewFollowUpChip('');
    setNewFollowUpResponse('');
    setNewFollowUpResponseType('custom');
    setNewFollowUpLinkedResponseId(null);
  };

  const handleAddTryAskingPrompt = () => {
    const trimmedPrompt = newTryAskingPrompt.trim();
    if (trimmedPrompt && tryAskingPrompts.length < 5 && !tryAskingPrompts.includes(trimmedPrompt)) {
      setTryAskingPrompts([...tryAskingPrompts, trimmedPrompt]);
      setNewTryAskingPrompt('');
    }
  };

  const handleRemoveTryAskingPrompt = (index: number) => {
    const newPrompts = tryAskingPrompts.filter((_, i) => i !== index);
    setTryAskingPrompts(newPrompts);
  };

  const handleAddFollowUpChip = () => {
    const trimmedChip = newFollowUpChip.trim();
    
    // Validate based on response type
    let isValid = false;
    if (newFollowUpResponseType === 'custom') {
      const trimmedResponse = newFollowUpResponse.trim();
      isValid = trimmedChip && trimmedResponse && trimmedResponse !== '<p></p>';
    } else if (newFollowUpResponseType === 'existing') {
      isValid = trimmedChip && newFollowUpLinkedResponseId !== null;
    }

    if (isValid && followUpChips.length < 5 && !followUpChips.includes(trimmedChip)) {
      setFollowUpChips([...followUpChips, trimmedChip]);
      setFollowUpResponseTypes([...followUpResponseTypes, newFollowUpResponseType]);
      
      if (newFollowUpResponseType === 'custom') {
        setFollowUpResponses([...followUpResponses, newFollowUpResponse.trim()]);
        setFollowUpLinkedResponseIds([...followUpLinkedResponseIds, 0]); // 0 for custom responses
      } else {
        setFollowUpResponses([...followUpResponses, '']); // Empty for existing responses
        setFollowUpLinkedResponseIds([...followUpLinkedResponseIds, newFollowUpLinkedResponseId!]);
      }
      
      setNewFollowUpChip('');
      setNewFollowUpResponse('');
      setNewFollowUpResponseType('custom');
      setNewFollowUpLinkedResponseId(null);
    }
  };

  const handleRemoveFollowUpChip = (index: number) => {
    const newChips = followUpChips.filter((_, i) => i !== index);
    const newResponses = followUpResponses.filter((_, i) => i !== index);
    const newResponseTypes = followUpResponseTypes.filter((_, i) => i !== index);
    const newLinkedResponseIds = followUpLinkedResponseIds.filter((_, i) => i !== index);
    
    setFollowUpChips(newChips);
    setFollowUpResponses(newResponses);
    setFollowUpResponseTypes(newResponseTypes);
    setFollowUpLinkedResponseIds(newLinkedResponseIds);
  };

  const handleCancelAdd = () => {
    setIsAddingMockResponse(false);
    setNewMockQuestion('');
    setNewMockResponse('');
    setShowTryAsking(false);
    setTryAskingPrompts([]);
    setShowFollowUp(false);
    setFollowUpQuestion('');
    setFollowUpChips([]);
    setFollowUpResponses([]);
    setFollowUpResponseTypes([]);
    setFollowUpLinkedResponseIds([]);
    setNewFollowUpChip('');
    setNewFollowUpResponse('');
    setNewFollowUpResponseType('custom');
    setNewFollowUpLinkedResponseId(null);
  };

  // Copy question to clipboard
  const handleCopyQuestion = async (question: string, mockResponseId: number) => {
    try {
      await navigator.clipboard.writeText(question);

      // Add visual feedback
      setCopiedQuestions(prev => new Set(prev).add(mockResponseId));

      // Reset after 2 seconds
      setTimeout(() => {
        setCopiedQuestions(prev => {
          const newSet = new Set(prev);
          newSet.delete(mockResponseId);
          return newSet;
        });
      }, 2000);

      toast({
        title: "Copied!",
        description: "Question copied to clipboard",
      });
    } catch (err) {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = question;
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');

        // Add visual feedback for fallback too
        setCopiedQuestions(prev => new Set(prev).add(mockResponseId));

        // Reset after 2 seconds
        setTimeout(() => {
          setCopiedQuestions(prev => {
            const newSet = new Set(prev);
            newSet.delete(mockResponseId);
            return newSet;
          });
        }, 2000);

        toast({
          title: "Copied!",
          description: "Question copied to clipboard",
        });
      } catch (fallbackErr) {
        toast({
          title: "Error",
          description: "Failed to copy question to clipboard",
          variant: "destructive",
        });
      }
      document.body.removeChild(textArea);
    }
  };

  // Filter and paginate mock responses
  const filteredMockResponses = mockResponses?.filter(mockResponse =>
    mockResponse.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
    mockResponse.response.toLowerCase().includes(searchTerm.toLowerCase())
  ) || [];

  const totalPages = Math.ceil(filteredMockResponses.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const paginatedMockResponses = filteredMockResponses.slice(startIndex, startIndex + itemsPerPage);

  // Reset to first page when search term changes
  React.useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  if (isLoadingOpening || isLoadingSupporting || isLoadingQuestions || isLoadingMockResponses) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-gray-500">Loading...</div>
      </div>
    );
  }

  // Function to truncate response text
  const truncateResponse = (text: string, maxLength: number = 100) => {
    // Strip HTML tags for display
    const stripped = text.replace(/<[^>]*>/g, '');
    return stripped.length > maxLength ? stripped.substring(0, maxLength) + '...' : stripped;
  };

  return (
    <div className="w-full p-6">
      <div className="mb-6">
        <Button
          variant="ghost"
          onClick={onBack}
          className="mb-4"
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          Back to Chat
        </Button>
        <h1 className="text-2xl font-bold text-gray-900">Admin Settings</h1>

        {/* Navigation Tabs */}
        <div className="mt-6 border-b border-gray-200">
          <nav className="flex space-x-8">
            <button
              onClick={() => setActiveTab('home')}
              className={`py-2 px-1 border-b-2 font-medium text-sm ${
                activeTab === 'home'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              Home Screen
            </button>
            <button
              onClick={() => setActiveTab('responses')}
              className={`py-2 px-1 border-b-2 font-medium text-sm ${
                activeTab === 'responses'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              Mock Responses
            </button>
            <button
              onClick={() => setActiveTab('system')}
              className={`py-2 px-1 border-b-2 font-medium text-sm ${
                activeTab === 'system'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              System Prompt
            </button>
          </nav>
        </div>
      </div>
      {/* Home Screen Tab */}
      {activeTab === 'home' && (
        <div className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Intro Text</CardTitle>
            <CardDescription>
              This text appears as the main headline when users start a new chat. You can use this to set the tone and provide initial guidance.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Textarea
              value={openingText}
              onChange={(e) => setOpeningText(e.target.value)}
              placeholder="Enter the opening text that users will see..."
              className="min-h-[80px]"
            />
            <div className="flex justify-end">
              <Button
                onClick={handleSaveOpening}
                disabled={updateOpeningTextMutation.isPending}
              >
                {updateOpeningTextMutation.isPending ? 'Saving...' : 'Save Intro Text'}
              </Button>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Supporting Text</CardTitle>
            <CardDescription>
              This text appears below the opening text to provide additional context or instructions for users.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Textarea
              value={supportingText}
              onChange={(e) => setSupportingText(e.target.value)}
              placeholder="Enter the supporting text that appears below the opening text..."
              className="min-h-[80px]"
            />
            <div className="flex justify-end">
              <Button
                onClick={handleSaveSupporting}
                disabled={updateSupportingTextMutation.isPending}
              >
                {updateSupportingTextMutation.isPending ? 'Saving...' : 'Save Supporting Text'}
              </Button>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Introductory Questions</CardTitle>
            <CardDescription>
              These are the suggested questions that appear as buttons when users start a new chat. Enter each question on a separate line.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Textarea
              value={introQuestions}
              onChange={(e) => setIntroQuestions(e.target.value)}
              placeholder="Enter each question on a separate line..."
              className="min-h-[120px]"
            />
            <div className="flex justify-end">
              <Button
                onClick={handleSaveQuestions}
                disabled={updateIntroQuestionsMutation.isPending}
              >
                {updateIntroQuestionsMutation.isPending ? 'Saving...' : 'Save Questions'}
              </Button>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Try Asking Suggestions</CardTitle>
            <CardDescription>
              Controls whether "Try asking" suggestions appear in the chat interface. When enabled, users see suggested questions after AI responses.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col">
                <label className="text-sm font-medium text-gray-700">
                  Show Try Asking Suggestions
                </label>
                <p className="text-xs text-gray-500">
                  Enable or disable "Try asking" suggestions globally
                </p>
              </div>
              <Switch
                checked={tryAskingEnabled}
                onCheckedChange={setTryAskingEnabled}
              />
            </div>
            <div className="flex justify-end">
              <Button
                onClick={handleSaveTryAskingEnabled}
                disabled={updateTryAskingEnabledMutation.isPending}
              >
                {updateTryAskingEnabledMutation.isPending ? 'Saving...' : 'Save Setting'}
              </Button>
            </div>
          </CardContent>
        </Card>
        </div>
      )}
      {/* Mock Responses Tab */}
      {activeTab === 'responses' && (
        <div className="space-y-6">
          <div className="flex items-center justify-between">
            <div>
              <h2 className="text-lg font-semibold text-gray-900">Mock Responses</h2>
              <p className="text-sm text-gray-600">Configure automatic responses for specific questions.</p>
            </div>
            <Button
              onClick={() => setIsAddingMockResponse(true)}
              size="sm"
              variant="outline"
            >
              <Plus className="w-4 h-4 mr-2" />
              Add Mock Response
            </Button>
          </div>

          {/* Search and Stats */}
          <div className="flex items-center justify-between gap-4">
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              <Input
                placeholder="Search questions or responses..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-4"
              />
            </div>
            <div className="text-sm text-gray-500">
              {filteredMockResponses.length} of {mockResponses?.length || 0} responses
            </div>
          </div>

          {/* Mock Responses Table */}
          {paginatedMockResponses && paginatedMockResponses.length > 0 ? (
            <div className="bg-white border rounded-lg overflow-hidden p-0" style={{ overflow: 'hidden' }}>
              <table className="w-full">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Question
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Response
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Last Updated
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {paginatedMockResponses.map((mockResponse: MockResponse) => (
                    <tr key={mockResponse.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4">
                        <div 
                          className={`text-sm font-medium max-w-xs cursor-pointer transition-all duration-200 rounded px-2 py-1 -mx-2 -my-1 relative group line-clamp-2 ${
                            copiedQuestions.has(mockResponse.id)
                              ? 'text-green-700 bg-green-100' 
                              : 'text-gray-900 hover:text-blue-600 hover:bg-blue-50'
                          }`}
                          onClick={() => handleCopyQuestion(mockResponse.question, mockResponse.id)}
                          title={copiedQuestions.has(mockResponse.id) ? "Copied!" : "Click to copy question"}
                          style={{
                            display: '-webkit-box',
                            WebkitLineClamp: 2,
                            WebkitBoxOrient: 'vertical',
                            overflow: 'hidden'
                          }}
                        >
                          {mockResponse.question}
                          {copiedQuestions.has(mockResponse.id) ? (
                            <CheckCircle className="absolute right-1 top-1/2 transform -translate-y-1/2 w-3 h-3 text-green-600 animate-in zoom-in duration-200" />
                          ) : (
                            <Copy className="absolute right-1 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity duration-200" />
                          )}
                        </div>
                      </td>
                      <td className="px-6 py-4">
                        <div className="text-sm text-gray-900 max-w-lg">
                          {truncateResponse(mockResponse.response, 150)}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">
                          {mockResponse.updatedAt 
                            ? new Date(mockResponse.updatedAt).toLocaleDateString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                              })
                            : 'N/A'
                          }
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex gap-2 justify-end">
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => handleEditMockResponse(mockResponse)}
                            title="Edit"
                          >
                            <Edit className="w-4 h-4" />
                          </Button>
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => handleDeleteMockResponse(mockResponse.id)}
                            disabled={deleteMockResponseMutation.isPending}
                            title="Delete"
                          >
                            <Trash2 className="w-4 h-4" />
                          </Button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : mockResponses && mockResponses.length > 0 ? (
            <div className="text-center py-8 text-gray-500">
              No mock responses match your search. Try different keywords or clear the search.
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500">
              No mock responses configured yet. Click "Add Mock Response" to create your first one.
            </div>
          )}

          {/* Pagination */}
          {totalPages > 1 && (
            <div className="flex items-center justify-between pt-4 border-t">
              <div className="text-sm text-gray-500">
                Showing {startIndex + 1}-{Math.min(startIndex + itemsPerPage, filteredMockResponses.length)} of {filteredMockResponses.length}
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setCurrentPage(currentPage - 1)}
                  disabled={currentPage === 1}
                >
                  <ChevronLeft className="w-4 h-4" />
                  Previous
                </Button>
                <span className="text-sm text-gray-500">
                  Page {currentPage} of {totalPages}
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setCurrentPage(currentPage + 1)}
                  disabled={currentPage === totalPages}
                >
                  Next
                  <ChevronRight className="w-4 h-4" />
                </Button>
              </div>
            </div>
          )}
        </div>
      )}
      {/* Add Mock Response Modal */}
      <Modal
        isOpen={isAddingMockResponse}
        onClose={handleCancelAdd}
        title="Add Mock Response"
        className="max-w-2xl"
      >
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Question
            </label>
            <Input
              value={newMockQuestion}
              onChange={(e) => setNewMockQuestion(e.target.value)}
              placeholder="Enter the exact question users will ask..."
              className="w-full"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Response
            </label>
            <RichTextEditor
              value={newMockResponse}
              onChange={setNewMockResponse}
              placeholder="Enter the response the chatbot should give..."
              className="w-full"
            />
          </div>

          {/* Try Asking Prompts Section */}
          <div className="border-t pt-4">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700">
                Try Asking Suggestions
              </label>
              <Switch
                checked={showTryAsking}                onCheckedChange={setShowTryAsking}
              />
            </div>

            {showTryAsking && (
              <div className="space-y-3">
                <p className="text-xs text-gray-500">
                  Add up to 5 custom prompts that will appear as "Try asking" suggestions with this response.
                </p>

                {/* Input for new prompt */}
                <div className="flex gap-2">
                  <Input
                    value={newTryAskingPrompt}
                    onChange={(e) => setNewTryAskingPrompt(e.target.value)}
                    placeholder="Enter a suggestion..."
                    className="flex-1"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault();
                        handleAddTryAskingPrompt();
                      }
                    }}
                  />
                  <Button
                    type="button"
                    onClick={handleAddTryAskingPrompt}
                    disabled={!newTryAskingPrompt.trim() || tryAskingPrompts.length >= 5}
                    size="sm"
                  >
                    Add
                  </Button>
                </div>

                {/* Display current prompts */}
                {tryAskingPrompts.length > 0 && (
                  <div className="space-y-2">
                    <div className="text-xs text-gray-500">
                      Current suggestions ({tryAskingPrompts.length}/5):
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {tryAskingPrompts.map((prompt, index) => (
                        <div
                          key={index}
                          className="flex items-center gap-1 bg-blue-50 text-blue-700 px-2 py-1 rounded-full text-sm"
                        >
                          <span>{prompt}</span>
                          <button
                            type="button"
                            onClick={() => handleRemoveTryAskingPrompt(index)}
                            className="text-blue-500 hover:text-blue-700"
                          >
                            <X size={14} />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Follow-up Question Section */}
          <div className="border-t pt-4">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700">
                Follow up question
              </label>
              <Switch
                checked={showFollowUp}
                onCheckedChange={setShowFollowUp}
              />
            </div>

            {showFollowUp && (
              <div className="space-y-3">
                <p className="text-xs text-gray-500">
                  Configure a follow-up question with custom chips and responses for each chip.
                </p>

                {/* Follow-up question input */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Question
                  </label>
                  <Input
                    value={followUpQuestion}
                    onChange={(e) => setFollowUpQuestion(e.target.value)}
                    placeholder="Would you like more details on a specified oxidizer?"
                    className="w-full"
                  />
                </div>

                {/* Add chip and response */}
                <div className="space-y-3">
                  <label className="block text-sm font-medium text-gray-700">
                    Add chip and response
                  </label>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Chip text
                    </label>
                    <Input
                      value={newFollowUpChip}
                      onChange={(e) => setNewFollowUpChip(e.target.value)}
                      placeholder="Chip text (e.g., 'Yes')"
                      className="w-full"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Response for this chip
                    </label>
                    <RichTextEditor
                      value={newFollowUpResponse}
                      onChange={setNewFollowUpResponse}
                      placeholder="Enter the response when this chip is clicked..."
                      className="w-full"
                    />
                  </div>
                  <Button
                    type="button"
                    onClick={handleAddFollowUpChip}
                    disabled={!newFollowUpChip.trim() || !newFollowUpResponse.trim() || newFollowUpResponse.trim() === '<p></p>' || followUpChips.length >= 5}
                    size="sm"
                  >
                    Add Chip
                  </Button>
                </div>

                {/* Display current chips */}
                {followUpChips.length > 0 && (
                  <div className="space-y-2">
                    <div className="text-xs text-gray-500">
                      Current chips ({followUpChips.length}/5):
                    </div>
                    <div className="space-y-2">
                      {followUpChips.map((chip, index) => (
                        <div
                          key={index}
                          className="flex items-center gap-2 p-2 bg-gray-50 rounded border"
                        >
                          <div className="flex-1">
                            <div className="font-medium text-sm">{chip}</div>
                            <div className="text-xs text-gray-600" dangerouslySetInnerHTML={{ __html: followUpResponses[index] }} />
                          </div>
                          <button
                            type="button"
                            onClick={() => handleRemoveFollowUpChip(index)}
                            className="text-red-500 hover:text-red-700"
                          >
                            <X size={14} />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="flex justify-end gap-2">
            <Button
              variant="outline"
              onClick={handleCancelAdd}
            >
              Cancel
            </Button>
            <Button
              onClick={handleCreateMockResponse}
              disabled={createMockResponseMutation.isPending || !newMockQuestion.trim() || !newMockResponse.trim() || newMockResponse.trim() === '<p></p>'}
            >
              {createMockResponseMutation.isPending ? 'Creating...' : 'Create Mock Response'}
            </Button>
          </div>
        </div>
      </Modal>
      {/* Edit Mock Response Modal */}
      <Modal
        isOpen={!!editingMockResponse}
        onClose={handleCancelEdit}
        title="Edit Mock Response"
        className="max-w-2xl"
      >
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Question
            </label>
            <Input
              value={newMockQuestion}
              onChange={(e) => setNewMockQuestion(e.target.value)}
              placeholder="Enter the exact question users will ask..."
              className="w-full"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Response
            </label>
            <RichTextEditor
              value={newMockResponse}
              onChange={setNewMockResponse}
              placeholder="Enter the response the chatbot should give..."
              className="w-full"
            />
          </div>

          {/* Try Asking Prompts Section */}
          <div className="border-t pt-4">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700">
                Try Asking Suggestions
              </label>
              <Switch
                checked={showTryAsking}
                onCheckedChange={setShowTryAsking}
              />
            </div>

            {showTryAsking && (
              <div className="space-y-3">
                <p className="text-xs text-gray-500">
                  Add up to 5 custom prompts that will appear as "Try asking" suggestions with this response.
                </p>

                {/* Input for new prompt */}
                <div className="flex gap-2">
                  <Input
                    value={newTryAskingPrompt}
                    onChange={(e) => setNewTryAskingPrompt(e.target.value)}
                    placeholder="Enter a suggestion..."
                    className="flex-1"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault();
                        handleAddTryAskingPrompt();
                      }
                    }}
                  />
                  <Button
                    type="button"
                    onClick={handleAddTryAskingPrompt}
                    disabled={!newTryAskingPrompt.trim() || tryAskingPrompts.length >= 5}
                    size="sm"
                  >
                    Add
                  </Button>
                </div>

                {/* Display current prompts */}
                {tryAskingPrompts.length > 0 && (
                  <div className="space-y-2">
                    <div className="text-xs text-gray-500">
                      Current suggestions ({tryAskingPrompts.length}/5):
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {tryAskingPrompts.map((prompt, index) => (
                        <div
                          key={index}
                          className="flex items-center gap-1 bg-blue-50 text-blue-700 px-2 py-1 rounded-full text-sm"
                        >
                          <span>{prompt}</span>
                          <button
                            type="button"
                            onClick={() => handleRemoveTryAskingPrompt(index)}
                            className="text-blue-500 hover:text-blue-700"
                          >
                            <X size={14} />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Follow-up Question Section */}
          <div className="border-t pt-4">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700">
                Follow up question
              </label>
              <Switch
                checked={showFollowUp}
                onCheckedChange={setShowFollowUp}
              />
            </div>

            {showFollowUp && (
              <div className="space-y-3">
                <p className="text-xs text-gray-500">
                  Configure a follow-up question with custom chips and responses for each chip.
                </p>

                {/* Follow-up question input */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Question
                  </label>
                  <Input
                    value={followUpQuestion}
                    onChange={(e) => setFollowUpQuestion(e.target.value)}
                    placeholder="Would you like more details on a specified oxidizer?"
                    className="w-full"
                  />
                </div>

                {/* Add chip and response */}
                <div className="space-y-3">
                  <label className="block text-sm font-medium text-gray-700">
                    Add chip and response
                  </label>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Chip text
                    </label>
                    <Input
                      value={newFollowUpChip}
                      onChange={(e) => setNewFollowUpChip(e.target.value)}
                      placeholder="Chip text (e.g., 'Yes')"
                      className="w-full"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Response for this chip
                    </label>
                    <RichTextEditor
                      value={newFollowUpResponse}
                      onChange={setNewFollowUpResponse}
                      placeholder="Enter the response when this chip is clicked..."
                      className="w-full"
                    />
                  </div>
                  <Button
                    type="button"
                    onClick={handleAddFollowUpChip}
                    disabled={!newFollowUpChip.trim() || !newFollowUpResponse.trim() || newFollowUpResponse.trim() === '<p></p>' || followUpChips.length >= 5}
                    size="sm"
                  >
                    Add Chip
                  </Button>
                </div>

                {/* Display current chips */}
                {followUpChips.length > 0 && (
                  <div className="space-y-2">
                    <div className="text-xs text-gray-500">
                      Current chips ({followUpChips.length}/5):
                    </div>
                    <div className="space-y-2">
                      {followUpChips.map((chip, index) => (
                        <div
                          key={index}
                          className="flex items-center gap-2 p-2 bg-gray-50 rounded border"
                        >
                          <div className="flex-1">
                            <div className="font-medium text-sm">{chip}</div>
                            <div className="text-xs text-gray-600" dangerouslySetInnerHTML={{ __html: followUpResponses[index] }} />
                          </div>
                          <button
                            type="button"
                            onClick={() => handleRemoveFollowUpChip(index)}
                            className="text-red-500 hover:text-red-700"
                          >
                            <X size={14} />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="flex justify-end gap-2">
            <Button
              variant="outline"
              onClick={handleCancelEdit}
            >
              Cancel
            </Button>
            <Button
              onClick={handleUpdateMockResponse}
              disabled={updateMockResponseMutation.isPending || !newMockQuestion.trim() || !newMockResponse.trim() || newMockResponse.trim() === '<p></p>'}
            >
              {updateMockResponseMutation.isPending ? 'Updating...' : 'Update Mock Response'}
            </Button>
          </div>
        </div>
      </Modal>
      {/* System Prompt Tab */}
      {activeTab === 'system' && (
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>OpenAI System Prompt</CardTitle>
              <CardDescription>
                This is the system prompt that will be sent to OpenAI when generating responses. It defines the AI's behavior, tone, and output format. Changes take effect immediately for new conversations.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <Textarea
                value={systemPrompt}
                onChange={(e) => setSystemPrompt(e.target.value)}
                placeholder="Enter the system prompt for OpenAI..."
                className="min-h-[200px] font-mono text-sm"
              />
              <div className="flex justify-end">
                <Button
                  onClick={handleSaveSystemPrompt}
                  disabled={updateSystemPromptMutation.isPending}
                >
                  {updateSystemPromptMutation.isPending ? 'Saving...' : 'Save System Prompt'}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
};